\[ [Index](index.md) | [Exercise 2.2](ex2_2.md) | [Exercise 2.4](ex2_4.md) \]

# Упражнение 2.3

_Задачи:_

- Итерировать как про

_Изменяемые файлы:_ None.

Итерация - это важный навык в Python.
В этом упражнении мы рассмотрим несколько распространенных идиом итерации.

Начните упражнение с получения нескольких строк данных из CSV-файла.

```python
>>> import csv
>>> f = open('Data/portfolio.csv')
>>> f_csv = csv.reader(f)
>>> headers = next(f_csv)
>>> headers
['name', 'shares', 'price']
>>> rows = list(f_csv)
>>> from pprint import pprint
>>> pprint(rows)
[['AA', '100', '32.20'],
 ['IBM', '50', '91.10'],
 ['CAT', '150', '83.44'],
 ['MSFT', '200', '51.23'],
 ['GE', '95', '40.37'],
 ['MSFT', '50', '65.10'],
 ['IBM', '100', '70.44']]
>>>
```

## (a) Базовая итерация и распаковка значений

Выражение `for` итерируется по любой последовательности. Например:

```python
>>> for row in rows:
        print(row)

['AA', '100', '32.20']
['IBM', '50', '91.10']
['CAT', '150', '83.44']
['MSFT', '200', '51.23']
['GE', '95', '40.37']
['MSFT', '50', '65.10']
['IBM', '100', '70.44']
>>>
```

Распакуйте значения в отдельные переменные, если это необходимо:

```python
>>> for name, shares, price in rows:
        print(name, shares, price)

AA 100 32.20
IBM 50 91.10
CAT 150 83.44
MSFT 200 51.23
GE 95 40.37
MSFT 50 65.10
IBM 100 70.44
>>>
```

Довольно часто используется `_` в качестве переменной,
если вам не важно значение. Например:

```python
>>> for name, _, price in rows:
        print(name, price)

AA 32.20
IBM 91.10
CAT 83.44
MSFT 51.23
GE 40.37
MSFT 65.10
IBM 70.44
>>>
```

Если вы не знаете, сколько значений будет распаковано,
вы можете использовать `*` как подстановочный символ.
Попробуйте этот эксперимент с группировкой данных по имени:

```python
>>> from collections import defaultdict
>>> byname = defaultdict(list)
>>> for name, *data in rows:
        byname[name].append(data)

>>> byname['IBM']
[['50', '91.10'], ['100', '70.44']]
>>> byname['CAT']
[['150', '83.44']]
>>> for shares, price in byname['IBM']:
        print(shares, price)

50 91.10
100 70.44
>>>
```

## (b) Подсчет с помощью функции enumerate()

`enumerate()` является полезной функцией, если вам понадобится вести счетчик
или индекс во время итерации. Например, вам нужен дополнительный ряд c номером:

```python
>>> for rowno, row in enumerate(rows):
        print(rowno, row)

0 ['AA', '100', '32.20']
1 ['IBM', '50', '91.10']
2 ['CAT', '150', '83.44']
3 ['MSFT', '200', '51.23']
4 ['GE', '95', '40.37']
5 ['MSFT', '50', '65.10']
6 ['IBM', '100', '70.44']
>>>
```

Можно объединить это с распаковкой, если осторожно подойти к структурированию:

```python
>>> for rowno, (name, shares, price) in enumerate(rows):
        print(rowno, name, shares, price)

0 AA 100 32.20
1 IBM 50 91.10
2 CAT 150 83.44
3 MSFT 200 51.23
4 GE 95 40.37
5 MSFT 50 65.10
6 IBM 100 70.44
>>>
```

## (c) Использование функции zip()

Функция `zip()` обычно используется для совмещения данных.
Например создадим переменную `headers` с заголовками:

```python
>>> headers
['name', 'shares', 'price']
>>>
```

Теперь ее можно объединить с данными:

```python
>>> row = rows[0]
>>> row
['AA', '100', '32.20']
>>> for col, val in zip(headers, row):
        print(col, val)

name AA
shares 100
price 32.20
>>>
```

Или можно создать словарь:

```python
>>> dict(zip(headers, row))
{'name': 'AA', 'shares': '100', 'price': '32.20'}
>>>
```

Или последовательность словарей:

```python
>>> for row in rows:
        record = dict(zip(headers, row))
        print(record)

{'name': 'AA', 'shares': '100', 'price': '32.20'}
{'name': 'IBM', 'shares': '50', 'price': '91.10'}
{'name': 'CAT', 'shares': '150', 'price': '83.44'}
{'name': 'MSFT', 'shares': '200', 'price': '51.23'}
{'name': 'GE', 'shares': '95', 'price': '40.37'}
{'name': 'MSFT', 'shares': '50', 'price': '65.10'}
{'name': 'IBM', 'shares': '100', 'price': '70.44'}
>>>
```

## (d) Генераторные выражения

Генераторное выражение почти такое же, как списковое
включение, за исключением того, что оно не создает список. Вместо этого
он создает объект-генератор, который отложенно производит результаты - обычно
для использования в итерации. Попробуйте простой пример:

```python
>>> nums = [1,2,3,4,5]
>>> squares = (x*x for x in nums)
>>> squares
<generator object <genexpr> at 0x37caa8>
>>> for n in squares:
        print(n)

1
4
9
16
25
>>>
```

Заметьте, что генераторное выражение можно использовать только один раз.
Посмотрите, что произойдет, если вы повторно выполните цикл for:

```python
>>> for n in squares:
        print(n)

>>>
```

Вы можете получить результаты по одному с помощью
функции `next()`. Попробуйте следующее:

```python
>>> squares = (x*x for x in nums)
>>> next(squares)
1
>>> next(squares)
4
>>> next(squares)
9
>>>
```

Продолжайте вводить `next()`, чтобы увидеть, что происходит, когда данных больше нет.

Если задача, которую вы выполняете, более сложная, вы можете воспользоваться преимуществами генераторов,
написав функцию-генератор используя оператор `yield` вместо `return`.
Например:

```python
>>> def squares(nums):
        for x in nums:
            yield x*x

>>> for n in squares(nums):
        print(n)

1
4
9
16
25
>>>
```

Мы вернемся к функциям-генераторам немного позже в курсе - пока
просто считайте такие функции интересными тем, что они позволяют
подавать значения в оператор `for`.

## (e) Генераторные выражения и reduce функции

Генераторные выражения особенно полезны для передачи данных в
функции `sum()`, `min()`, `max()`, `any()`. Попробуйте несколько примеров с использованием данных прошлых уроков.
Обратите внимание, что в этих примерах отсутствуют некоторые
дополнительные квадратные скобки ([]), которые появлялись при использовании списковых включений.

```python
>>> from readport import read_portfolio
>>> portfolio = read_portfolio('Data/portfolio.csv')
>>> sum(s['shares']*s['price'] for s in portfolio)
44671.15
>>> min(s['shares'] for s in portfolio)
50
>>> any(s['name'] == 'IBM' for s in portfolio)
True
>>> all(s['name'] == 'IBM' for s in portfolio)
False
>>> sum(s['shares'] for s in portfolio if s['name'] == 'IBM')
150
>>>
```

Вот использование генераторного выражения для создании значений, разделенных запятой:

```python
>>> s = ('GOOG',100,490.10)
>>> ','.join(s)
... observe that it fails ...
>>> ','.join(str(x) for x in s)    # This works
'GOOG,100,490.1'
>>>
```

Синтаксис в приведенных выше примерах требует привыкания, но
ключевое преимущество такого подхода в том, что ни одна из операций не выполняется сразу для всего набора данных.
Это позволяет экономить память, выполняя операции поэлементно.

## (f) Экономия памяти

В [упражнении 2.1](ex2_1.md) вы написали функцию
`read_rides_as_dicts()`, которая считывает данные автобусов CTA в список
словарей. Его использование требует много памяти. Давайте найдем день, в который у маршрута автобуса № 22 было наибольшее
количество пассажиров:

```python
>>> import tracemalloc
>>> tracemalloc.start()
>>> import readrides
>>> rows = readrides.read_rides_as_dicts('Data/ctabus.csv')
>>> rt22 = [row for row in rows if row['route'] == '22']
>>> max(rt22, key=lambda row: row['rides'])
{'date': '06/11/2008', 'route': '22', 'daytype': 'W', 'rides': 26896}
>>> tracemalloc.get_traced_memory()
... Посмотрите на результат, он должен быть примерно 220MB
>>>
```

Теперь попробуем пример с использованием генераторов. Перезапустите Python
и попробуйте следующее:

```python
>>> # RESTART
>>> import tracemalloc
>>> tracemalloc.start()
>>> import csv
>>> f = open('Data/ctabus.csv')
>>> f_csv = csv.reader(f)
>>> headers = next(f_csv)
>>> rows = (dict(zip(headers,row)) for row in f_csv)
>>> rt22 = (row for row in rows if row['route'] == '22')
>>> max(rt22, key=lambda row: int(row['rides']))
{'date': '06/11/2008', 'route': '22', 'daytype': 'W', 'rides': 26896}
>>> tracemalloc.get_traced_memory()
... посмотрите на результат. Он должен быть на порядок ниже
>>>
```

Имейте в виду, что вы только что обработали всю базу данных, как последовательность словарей,
однако вы нигде не создавали и не хранили весь список.
Не все задачи могут быть так решены, но если вы можете работать с данными итеративным образом
генераторные выражения сэкономят огромное количество памяти.

\[ [Solution](soln2_3.md) | [Index](index.md) | [Exercise 2.2](ex2_2.md) | [Exercise 2.4](ex2_4.md) \]

---

`>>>` Advanced Python Mastery  
`...` A course by [dabeaz](https://www.dabeaz.com)  
`...` Copyright 2007-2023

![](https://i.creativecommons.org/l/by-sa/4.0/88x31.png). This work is licensed under a [Creative Commons Attribution-ShareAlike 4.0 International License](http://creativecommons.org/licenses/by-sa/4.0/)
