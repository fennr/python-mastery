\[ [Index](index.md) | [Exercise 1.6](ex1_6.md) | [Exercise 2.2](ex2_2.md) \]

# Упражнение 2.1

_Задачи:_

- Поиск наиболее экономичного использования памяти при хранении большого объема данных.
- Изучение различных способов представления записей, включая кортежи, словари, классы и именованные кортежи.

В этом упражнении мы рассмотрим различные варианты представления структур данных с учетом использования памяти и эффективности.
Многие люди используют Python для различных видов анализа данных, поэтому знание различных вариантов и их компромиссов является полезной информацией.

## (a) Застряли в автобусе

Файл `Data/ctabus.csv` - это файл CSV, содержащий ежедневные данные о количестве пассажиров, использующих автобусную систему
Chicago Transit Authority (CTA) с 1 января 2001 года по 31 августа 2013 года.
Он содержит примерно 577000 строк. Используйте Python, чтобы посмотреть несколько строк и увидеть, как они выглядят:

```python
>>> f = open('Data/ctabus.csv')
>>> next(f)
'route,date,daytype,rides\n'
>>> next(f)
'3,01/01/2001,U,7354\n'
>>> next(f)
'4,01/01/2001,U,9288\n'
>>>
```

В файле есть 4 столбца данных:

- route: Столбец 0. Название маршрута автобуса.
- date: Столбец 1. Строка с датой в формате ММ/ДД/ГГГГ.
- daytype: Столбец 2. Код типа дня (U=воскресенье/праздничный, A=суббота, W=будний день)
- rides: Столбец 3. Общее количество пассажиров (целое число)

Столбец rides содержит общее количество людей, которые сели на автобус на этом маршруте в определенный день.
Таким образом, по приведенному примеру, 7354 человека воспользовались автобусом номер 3 1 января 2001 года.

## (b) Базовое использование памяти для текста

Начнем с получения базового уровня использования памяти, необходимого для работы с этим файлом данных.
Сначала перезапустите Python и попробуйте очень простой эксперимент, просто получив файл и сохраняя его данные в одной строке:

```python
>>> # --- RESTART
>>> import tracemalloc
>>> f = open('Data/ctabus.csv')
>>> tracemalloc.start()
>>> data = f.read()
>>> len(data)
12361039
>>> current, peak = tracemalloc.get_traced_memory()
>>> current
12369664
>>> peak
24730766
>>>
```

Ваши результаты могут немного отличаться, но вы должны увидеть текущее использование памяти в диапазоне 12 МБ, а пиковое использование - около 24 МБ.

Что произойдет, если вы прочитаете весь файл в список строк? Запустите Python снова и попробуйте следующее:

```python
>>> # --- RESTART
>>> import tracemalloc
>>> f = open('Data/ctabus.csv')
>>> tracemalloc.start()
>>> lines = f.readlines()
>>> len(lines)
577564
>>> current, peak = tracemalloc.get_traced_memory()
>>> current
45828030
>>> peak
45867371
>>>
```

Вы должны увидеть существенное увеличение использования памяти до значения в диапазоне 40-50 МБ.
Вопрос для размышления: что может являться источником этой дополнительной нагрузки?

## (c) Список кортежей

На практике вы можете прочитать данные в список и преобразовать каждую строку в другую структуру данных.
Вот программа `readrides.py`, которая читает весь файл в список кортежей с использованием модуля `csv`:

```python
# readrides.py

import csv

def read_rides_as_tuples(filename):
    '''
    Читает данные о поездках как список кортежей
    '''
    records = []
    with open(filename) as f:
        rows = csv.reader(f)
        headings = next(rows)     # Skip headers
        for row in rows:
            route = row[0]
            date = row[1]
            daytype = row[2]
            rides = int(row[3])
            record = (route, date, daytype, rides)
            records.append(record)
    return records

if __name__ == '__main__':
    import tracemalloc
    tracemalloc.start()
    rows = read_rides_as_tuples('Data/ctabus.csv')
    print('Использование памяти: Текущее %d, Пиковое %d' % tracemalloc.get_traced_memory())
```

Запустите эту программу, используя `python3 -i readrides.py` и посмотрите на полученное содержимое `rows`.
Вы должны получить список кортежей вроде такого:

```python
>>> len(rows)
577563
>>> rows[0]
('3', '01/01/2001', 'U', 7354)
>>> rows[1]
('4', '01/01/2001', 'U', 9288)
```

Посмотрите на полученное использование памяти. Оно должно быть значительно выше, чем в разделе (b).

## (d) Использование памяти другими структурами данных

В Python есть много различных вариантов представления данных. Например:

```python
# Кортеж
row = (route, date, daytype, rides)

# Словарь
row = {
    'route': route,
    'date': date,
    'daytype': daytype,
    'rides': rides,
}

# Класс
class Row:
    def __init__(self, route, date, daytype, rides):
        self.route = route
        self.date = date
        self.daytype = daytype
        self.rides = rides

# Именованный кортеж
from collections import namedtuple
Row = namedtuple('Row', ['route', 'date', 'daytype', 'rides'])

# Класс с __slots__
class Row:
    __slots__ = ['route', 'date', 'daytype', 'rides']
    def __init__(self, route, date, daytype, rides):
        self.route = route
        self.date = date
        self.daytype = daytype
        self.rides = rides
```

Ваша задача следующая: Создать разные версии функции `read_rides()`,
которые используют каждую из этих структур для представления одной строки.
Затем узнайте результирующее использование памяти для каждой структуры. Узнайте, какой
подход предлагает наиболее эффективное хранилище, если вы работаете с большим количеством
данных сразу.

\[ [Solution](soln2_1.md) | [Index](index.md) | [Exercise 1.6](ex1_6.md) | [Exercise 2.2](ex2_2.md) \]

---

`>>>` Advanced Python Mastery  
`...` A course by [dabeaz](https://www.dabeaz.com)  
`...` Copyright 2007-2023

![](https://i.creativecommons.org/l/by-sa/4.0/88x31.png). This work is licensed under a [Creative Commons Attribution-ShareAlike 4.0 International License](http://creativecommons.org/licenses/by-sa/4.0/)
