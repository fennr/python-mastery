\[ [Index](index.md) | [Exercise 2.4](ex2_4.md) | [Exercise 2.6](ex2_6.md) \]

# Упражнение 2.5

*Задачи:*

- Изучить выделение памяти для списков и словарей
- Создать пользовательский контейнер данных

*Созданные файлы:* None

## (a) Рост списка

Списки в Python оптимизированы для выполнения операций `append()`. 
Каждый раз, когда список растет, он занимает больше памяти, чем ему фактически нужно, 
с ожиданием того, что в список будет добавлено больше данных позже. 
Если новые элементы добавляются и имеется свободное место, операция `append()` 
сохраняет элемент без выделения дополнительной памяти.

Используйте эту особенность списков, используя функцию `sys.getsizeof()` 
на списке и добавив несколько элементов.

```python
>>> import sys
>>> items = []
>>> sys.getsizeof(items)
64
>>> items.append(1)
>>> sys.getsizeof(items)
96
>>> items.append(2)
>>> sys.getsizeof(items)    # Размер не увеличился
96
>>> items.append(3)
>>> sys.getsizeof(items)    # Еще не увеличился
96
>>> items.append(4)
>>> sys.getsizeof(items)    # Все еще нет
96
>>> items.append(5)
>>> sys.getsizeof(items)    # Увеличился!
128
>>>
```

Список хранит свои элементы по ссылке. Таким образом, требуемая память для каждого элемента - 
это один адрес памяти. На 64-битной машине адрес обычно занимает 8 байт. 
Однако, если Python скомпилирован под 32-бит, его размер может составлять 4 байта, 
и числа для вышеуказанного примера будут в два раза меньше.


## (b) Рост словаря/класса

Словари (и классы) в Python позволяют хранить до 5 значений, прежде чем их зарезервированная память удваивается. 
Исследуйте это, создавая словарь и добавляя несколько значений:

```python
>>> row = { 'route': '22', 'date': '01/01/2001', 'daytype': 'U', 'rides': 7354 }
>>> sys.getsizeof(row)
>>> sys.getsizeof(row)
240
>>> row['a'] = 1
>>> sys.getsizeof(row)
240
>>> row['b'] = 2
>>> sys.getsizeof(row)
368
>>> 
```

Уменьшается ли память, если вы удаляете только что добавленный элемент?

Мысли вслух: Если вы создаете большое количество записей, представление каждой записи 
в виде словаря может оказаться не самым эффективным подходом - 
вы можете заплатить слишком высокую цену за удобство в виде словаря. 
Возможно, лучше рассмотреть использование кортежей, именованных кортежей или 
классов с объявлением `__slots__`.

## (c) Изменение ориентации на столбцы (to Columns)

Вы часто можете сэкономить много памяти, изменив свою представление данных. 
Например, что произойдет, если вы прочитаете все данные по автобусам, используя эту функцию?

```python
# readrides.py

...

def read_rides_as_columns(filename):
    '''
    Прочитать все данные в 4 списка представляющих колонки
    '''
    routes = []
    dates = []
    daytypes = []
    numrides = []
    with open(filename) as f:
        rows = csv.reader(f)
        headings = next(rows)     # Skip headers
        for row in rows:
            routes.append(row[0])
            dates.append(row[1])
            daytypes.append(row[2])
            numrides.append(int(row[3]))
    return dict(routes=routes, dates=dates, daytypes=daytypes, numrides=numrides)
```

В теории эта функция должна сэкономить много памяти. Давайте проанализируем ее перед попыткой.

Сначала файл данных содержал 577563 строк данных, и каждая строка содержала четыре значения. 
Если каждая строка хранится в виде словаря, то словари занимают минимум 240 байт.

```python
>>> nrows = 577563     # Количество строк в файле
>>> nrows * 240
138615120
>>>
```

Таким образом, это 138 МБ только для самих словарей, без учета значений.

Перейдя к столбцам, данные хранятся в 4 отдельных списках. Каждый список требует 8 байт 
на элемент для хранения указателя. Вот примерная оценка требований к спискам:

```python
>>> nrows * 4 * 8
18482016
>>>
```

Всего это около 18 МБ издержек на списки. Переключение на столбцовую ориентацию 
должно экономить примерно 120 МБ памяти только за счет устранения 
всей дополнительной информации, которую нужно хранить в словарях.

Попробуйте использовать эту функцию для чтения данных об автобусе и изучите использование памяти.

```python
>>> import tracemalloc
>>> tracemalloc.start()
>>> columns = read_rides_as_columns('Data/ctabus.csv')
>>> tracemalloc.get_traced_memory()
... look at the result ...
>>>
```

Соответствует ли результат ожидаемым экономиям памяти, которые мы примерно рассчитали выше?

## (d) Создание пользовательского контейнера  - The Great Fake Out

Хранение данных в столбцах дает нам гораздо большую экономию памяти, но теперь 
с данными стало заметно сложнее работать. Фактически, ни один из наших ранее написанных 
аналитических кодов из [Упражнение 2.2](ex2_2.md) не может работать со столбцами. 
Проблема заключается в том, что вы нарушили абстракцию данных, которая использовалась 
в предыдущих упражнениях - а именно предположение, что данные хранятся в виде списка словарей.

Это можно исправить, если вы готовы создать пользовательский контейнерный объект, 
который "подделывает" его. Давайте сделаем это.

Ранее написанный аналитический код предполагает, что данные хранятся в последовательности записей. 
Каждая запись представляется в виде словаря. Начнем с создания нового класса "Sequence". 
В этом классе мы храним четыре столбца данных, которые использовались в функции `read_rides_as_columns()`.

```python
# readrides.py

import collections
...
class RideData(collections.Sequence):
    def __init__(self):
        self.routes = []      # Columns
        self.dates = []
        self.daytypes = []
        self.numrides = []
```

Попробуйте создать экземпляр `RideData`. 
Вы увидите, что он не работает и выдает сообщение об ошибке, подобное этому:

```python
>>> records = RideData()
Traceback (most recent call last):
...
TypeError: Can't instantiate abstract class RideData with abstract methods __getitem__, __len__
>>>
```

Тщательно прочитайте сообщение об ошибке. Оно говорит нам, что нам нужно реализовать. 
Добавим методы `__len__()` и `__getitem__()`. В методе `__getitem__()` мы создадим словарь. 
Кроме того, мы создадим метод `append()`, который принимает словарь и распаковывает его 
на 4 отдельные операции `append()`.

```python
# readrides.py
...

class RideData(collections.Sequence):
    def __init__(self):
        # Каждое значение это список всех значений колонки
        self.routes = []
        self.dates = []
        self.daytypes = []
        self.numrides = []
        
    def __len__(self):
        # Все списки имеют одинаковую длину
        return len(self.routes)

    def __getitem__(self, index):
        return { 'route': self.routes[index],
                 'date': self.dates[index],
                 'daytype': self.daytypes[index],
                 'rides': self.numrides[index] }

    def append(self, d):
        self.routes.append(d['route'])
        self.dates.append(d['date'])
        self.daytypes.append(d['daytype'])
        self.numrides.append(d['rides'])
```

Если вы это сделали правильно, вы должны суметь отправить этот объект в
ранее написанную функцию `read_rides_as_dicts()`. Это изменение
потребует изменения всего одной строки кода:

```python
# readrides.py
...

def read_rides_as_dicts(filename):
    '''
    Read the bus ride data as a list of dicts
    '''
    records = RideData()      # <--- ИЗМЕНЕНИЕ ЗДЕСЬ
    with open(filename) as f:
        rows = csv.reader(f)
        headings = next(rows)     # Пропускаем заголовки
        for row in rows:
            route = row[0]
            date = row[1]
            daytype = row[2]
            rides = int(row[3])
            record = {
                'route': route, 
                'date': date, 
                'daytype': daytype, 
                'rides' : rides
                }
            records.append(record)
    return records
```

Если вы все сделали правильно, старый код должен работать так же, как и раньше.
Например:

```python
>>> rows = readrides.read_rides_as_dicts('Data/ctabus.csv')
>>> rows
<readrides.RideData object at 0x10f5054a8>
>>> len(rows)
577563
>>> rows[0]
{'route': '3', 'date': '01/01/2001', 'daytype': 'U', 'rides': 7354}
>>> rows[1]
{'route': '4', 'date': '01/01/2001', 'daytype': 'U', 'rides': 9288}
>>> rows[2]
{'route': '6', 'date': '01/01/2001', 'daytype': 'U', 'rides': 6048}
>>> 
```

Запустите свой ранее написанный код CTA из [Упражнения 2.2](ex2_2.md). Он
должен работать без изменений, но использовать значительно меньше памяти.

## (e) Испытание

Что произойдет, когда вы возьмете срез данных о поездках?

```python
>>> r = rows[0:10]
>>> r
... посмотрите на результат ...
>>>
```

Вероятно, это будет выглядеть немного странно. Можете ли вы изменить
класс `RideData` так, чтобы он производил правильный срез, который
выглядит как список словарей? Например, так:

```python
>>> rows = readrides.read_rides_as_columns('Data/ctabus.csv')
>>> rows
<readrides.RideData object at 0x10f5054a8>
>>> len(rows)
577563
>>> r = rows[0:10]
>>> r
<readrides.RideData object at 0x10f5068c8>
>>> len(r)
10
>>> r[0]
{'route': '3', 'date': '01/01/2001', 'daytype': 'U', 'rides': 7354}
>>> r[1]
{'route': '4', 'date': '01/01/2001', 'daytype': 'U', 'rides': 9288}
>>>
```

\[ [Solution](soln2_5.md) | [Index](index.md) | [Exercise 2.4](ex2_4.md) | [Exercise 2.6](ex2_6.md) \]

----
`>>>` Advanced Python Mastery  
`...` A course by [dabeaz](https://www.dabeaz.com)  
`...` Copyright 2007-2023  

![](https://i.creativecommons.org/l/by-sa/4.0/88x31.png). This work is licensed under a [Creative Commons Attribution-ShareAlike 4.0 International License](http://creativecommons.org/licenses/by-sa/4.0/)
