\[ [Index](index.md) | [Exercise 3.2](ex3_2.md) | [Exercise 3.4](ex3_4.md) \]

# Упражнение 3.3

*Задачи:*

- Изучить атрибуты и методы класса

*Изменяемые файлы:* `stock.py`, `reader.py`

Обычно экземпляры класса `Stock` определенного в п
редыдущем упражнении, создаются следующим образом:

```python
>>> s = Stock('GOOG', 100, 490.1)
>>>
```

Однако функция `read_portfolio()`  также создает экземпляры на основе данных, 
считанных из файлов. Например, используется следующий код:

```python
>>> import csv
>>> f = open('Data/portfolio.csv')
>>> rows = csv.reader(f)
>>> headers = next(rows)
>>> row = next(rows)
>>> row
['AA', '100', '32.20']
>>> s = Stock(row[0], int(row[1]), float(row[2]))
>>>
```

## (a) Альтернативные конструкторы

Возможно, создание экземпляра `Stock` из строки сырых данных лучше обработать 
с помощью альтернативного конструктора. Измените класс `Stock` так, чтобы 
он имел классовую переменную `types` и классовый метод `from_row()` следующим образом:

```python
class Stock:
    types = (str, int, float)
    def __init__(self, name, shares, price):
        self.name = name
        self.shares = shares
        self.price = price

    @classmethod
    def from_row(cls, row):
        values = [func(val) for func, val in zip(cls.types, row)]
        return cls(*values)
    ...
```

Вот как это можно протестировать:

```python
>>> row = ['AA', '100', '32.20']
>>> s = Stock.from_row(row)
>>> s.name
'AA'
>>> s.shares
100
>>> s.price
32.2
>>> s.cost()
3220.0000000000005
>>>
```

Обратите внимание, как строковые значения были преобразованы в правильный тип.

## (b) Атрибуты класса и наследование

Классовые переменные, такие как `types` иногда используются в качестве механизма настраиваемости 
при использовании наследования. Например, в классе `Stock` `types` можно легко изменить в подклассе. 
Попробуйте этот пример, который изменяет атрибут `price` на экземпляр `Decimal` 
(он используется для финансовых расчетов):

```python
>>> from decimal import Decimal
>>> class DStock(Stock):
        types = (str, int, Decimal)

>>> row = ['AA', '100', '32.20']
>>> s = DStock.from_row(row)
>>> s.price
Decimal('32.20')
>>> s.cost()
Decimal('3220.0')
>>>
```

**Обсуждение дизайна**

Задачей, рассматриваемой в этом упражнении, является преобразование данных, считанных из файла. 
Возможно, имеет смысл выполнять эти преобразования в методе `__init__()` класса `Stock`? Например:

```python
class Stock:
    def __init__(self, name, shares, price):
        self.name = str(name)
        self.shares = int(shares)
        self.price = float(price)
```

Таким образом, вы бы преобразовали строку данных следующим образом:

```python
>>> row = ['AA', '100', '32.20']
>>> s = Stock(*row)
>>> s.name
'AA'
>>> s.shares
100
>>> s.price
32.2
>>>
```

Это хорошо или плохо? Какие у вас мысли? В целом, я считаю это сомнительным дизайном, 
так как он смешивает две разные вещи: создание экземпляра и преобразование данных. 
Кроме того, неявные преобразования в `__init__()` ограничивают гибкость и могут 
вызвать непредвиденные ошибки, если пользователь не аккуратен.

## (c) Чтение объектов

Измените функцию `read_portfolio()`, чтобы использовать новый метод `Stock.from_row()`, 
который вы написали.

Вопрос для размышления: Какая версия кода вам нравится больше? 
Версия `read_portfolio()`, которая выполняла преобразования типов, или версия, 
которая выполняет преобразования в методе `Stock.from_row()`?
Подумайте о возможностях абстракции данных.

Можете ли вы изменить функцию `read_portfolio()` так, чтобы создавать объекты 
с использованием класса, отличного от  `Stock`?  Например, может ли пользователь выбрать класс, который ему нужен?

## (d) Обобщение

Полезной особенностью методов класса является то, что они позволяют 
создавать высоконагруженный интерфейс создания экземпляров для широкого 
спектра классов и писать универсальные утилиты, использующие эти методы.

Ранее вы создали файл `reader.py` , в котором были некоторые функции для чтения данных CSV. 
Добавьте следующую функцию `read_csv_as_instances()` в файл, которая принимает класс в качестве 
входных данных и использует метод класса `from_row()` для создания списка экземпляров:

```python
# reader.py
...

def read_csv_as_instances(filename, cls):
    '''
    Read a CSV file into a list of instances
    '''
    records = []
    with open(filename) as f:
        rows = csv.reader(f)
        headers = next(rows)
        for row in rows:
            records.append(cls.from_row(row))
    return records
```

Избавьтесь от функции `read_portfolio()` она больше не нужна. Если вы хотите 
прочитать список объектов `Stock`, сделайте так:

```python
>>> # Экземпляры класса Stock
>>> from reader import read_csv_as_instances
>>> from stock import Stock
>>> portfolio = read_csv_as_instances('Data/portfolio.csv', Stock)
>>> portfolio
[<__main__.Stock object at 0x100674748>, 
<__main__.Stock object at 0x1006746d8>, 
<__main__.Stock object at 0x1006747b8>, 
<__main__.Stock object at 0x100674828>, 
<__main__.Stock object at 0x100674898>, 
<__main__.Stock object at 0x100674908>, 
<__main__.Stock object at 0x100674978>]
>>>
```

Вот пример того, как можно использовать `read_csv_as_instances()` с совершенно другим классом:

```python
>>> class Row:
         def __init__(self, route, date, daytype, numrides):
             self.route = route
             self.date = date
             self.daytype = daytype
             self.numrides = numrides
         @classmethod
         def from_row(cls, row):
             return cls(row[0], row[1], row[2], int(row[3]))

>>> rides = read_csv_as_instances('Data/ctabus.csv', Row)
>>> len(rides)
577563
>>>
```

**Обсуждение**

Это упражнение иллюстрирует две наиболее распространенные применения классовых переменных 
и классовых методов. Классовые переменные часто используются для хранения глобальных параметров 
(например, настроек конфигурации), которые используются всеми экземплярами. 
Иногда подклассы наследуются от базового класса и переопределяют параметры настройки 
для изменения поведения.

Классовые методы чаще всего используются для реализации альтернативных конструкторов, 
как показано выше. Обычным способом определения таких классовых методов является 
поиск слова "from" в имени. Например, вот пример для встроенных словарей:

```python
>>> d = dict.fromkeys(['a','b','c'], 0)     # метод класса
>>> d
{'a': 0, 'c': 0, 'b': 0}
>>>
```

\[ [Solution](soln3_3.md) | [Index](index.md) | [Exercise 3.2](ex3_2.md) | [Exercise 3.4](ex3_4.md) \]

----
`>>>` Advanced Python Mastery  
`...` A course by [dabeaz](https://www.dabeaz.com)  
`...` Copyright 2007-2023  

![](https://i.creativecommons.org/l/by-sa/4.0/88x31.png). This work is licensed under a [Creative Commons Attribution-ShareAlike 4.0 International License](http://creativecommons.org/licenses/by-sa/4.0/)
