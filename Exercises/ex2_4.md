\[ [Index](index.md) | [Exercise 2.3](ex2_3.md) | [Exercise 2.5](ex2_5.md) \]

# Упражнение 2.4

*Задачи:*

- Создать новый базовый тип

В большинстве программ используются базовые типы данных, такие как `int`, `float` и `str`, 
для представления данных. Однако вы не ограничены только этими типами. 
Стандартная библиотека содержит модули, такие как `decimal` и `fractions`, 
которые реализуют новые типы. Вы также можете создавать свои собственные типы, 
разбираясь с протоколами, которые обеспечивают работу объектов Python. 
В этом упражнении мы создадим новый базовый тип. Есть много мелких деталей, 
о которых нужно заботиться, но это даст вам общее представление о необходимом минимуме.

## (a) Изменяемые целые числа

Стандартные целые числа в Python являются неизменяемыми (immutable). 
Однако предположим, что вы хотите создать изменяемый объект целого числа. 
Начнем с создания класса, как показано ниже:

```python
# mutint.py

class MutInt:
    __slots__ = ['value']

    def __init__(self, value):
        self.value = value
```

Попробуйте:

```python
>>> a = MutInt(3)
>>> a
<__main__.MutInt object at 0x10e79d408>
>>> a.value
3
>>> a.value = 42
>>> a.value
42
>>> a + 10
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: unsupported operand type(s) for +: 'MutInt' and 'int'
>>>
```

Это всё очень захватывающе, но ничего не работает с этим новым объектом `MutInt`. 
Вывод на экран выглядит ужасно, математические операторы не работают, и в целом он бесполезен. 
Хотя... его значение уже изменяемо.

## (b) Исправление вывода

Вы можете исправить вывод, определив у объекта методы такие как `__str__()`,
`__repr__()` и `__format__()`.  Например:

```python
# mint.py

class MutInt:
    __slots__ = ['value']

    def __init__(self, value):
        self.value = value

    def __str__(self):
        return str(self.value)

    def __repr__(self):
        return f'MutInt({self.value!r})'

    def __format__(self, fmt):
        return format(self.value, fmt)
```

Попробуйте:

```python
>>> a = MutInt(3)
>>> print(a)
3
>>> a
MutInt(3)
>>> f'The value is {a:*^10d}'
The value is ****3*****
>>> a.value = 42
>>> a
MutInt(42)
>>>
```

## (c) Математические операторы

Вы можете заставить объект работать с различными математическими операторами, 
если реализуете соответствующие методы для этого. 
Однако вам нужно уметь определять другие типы данных и реализовывать код преобразования. 
Внесите изменения в класс `MutInt`, добавив метод `__add__()` следующим образом:

```python
class MutInt:
    __slots__ = ['value']

    def __init__(self, value):
        self.value = value

    ...

    def __add__(self, other):
        if isinstance(other, MutInt):
            return MutInt(self.value + other.value)
        elif isinstance(other, int):
            return MutInt(self.value + other)
        else:
            return NotImplemented
```

Сделав эти изменения, вы должны обнаружить, что можете складывать как целые числа, так и объекты `MutInt`. 
Результатом будет экземпляр класса `MutInt`. 
При сложении с другими типами чисел будет вызвано исключение:

```python
>>> a = MutInt(3)
>>> b = a + 10
>>> b
MutInt(13)
>>> b.value = 23
>>> c = a + b
>>> c
MutInt(26)
>>> a + 3.5
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: unsupported operand type(s) for +: 'MutInt' and 'float'
>>> 
```

Одной из проблем с этим кодом является то, что он не работает, если поменять порядок операндов. 
Рассмотрим следующий код:

```python
>>> a + 10
MutInt(13)
>>> 10 + a
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: unsupported operand type(s) for +: 'int' and 'MutInt'
>>> 
```

Такая ошибка происходит потому, что тип `int` не знает о типе `MutInt` и в нем возникает путаница. 
Это можно исправить, добавив метод `__radd__()`. 
Этот метод вызывается, если первая попытка вызова `__add__()` не сработала с переданным объектом.

```python
class MutInt:
    __slots__ = ['value']

    def __init__(self, value):
        self.value = value

    ...

    def __add__(self, other):
        if isinstance(other, MutInt):
            return MutInt(self.value + other.value)
        elif isinstance(other, int):
            return MutInt(self.value + other)
        else:
            return NotImplemented

    __radd__ = __add__    # Обратные операнды
```

После этих изменений сложение будет работать:

```python
>>> a = MutInt(3)
>>> a + 10
MutInt(13)
>>> 10 + a
MutInt(13)
>>>
```

Так как наше целое число (MutInt) является изменяемым, 
вы также можете сделать его совместимым с оператором `+=`, который выполняет присваивание с добавлением. 
Для этого реализуем метод `__iadd__()`:

```python
class MutInt:
    __slots__ = ['value']

    def __init__(self, value):
        self.value = value

    ...

    def __iadd__(self, other):
        if isinstance(other, MutInt):
            self.value += other.value
            return self
        elif isinstance(other, int):
            self.value += other
            return self
        else:
            return NotImplemented
```

Теперь можно делать интересные вещи, например:

```python
>>> a = MutInt(3)
>>> b = a
>>> a += 10
>>> a
MutInt(13)
>>> b                 # Обратите внимание, что b также изменяется
MutInt(13)
>>>
```

Покажется, что это странно, что b также изменяется, 
но встроенные объекты в Python могут иметь такие тонкости. Например:

```python
>>> a = [1,2,3]
>>> b = a
>>> a += [4,5]
>>> a
[1, 2, 3, 4, 5]
>>> b
[1, 2, 3, 4, 5]

>>> c = (1,2,3)
>>> d = c
>>> c += (4,5)
>>> c
(1, 2, 3, 4, 5)
>>> d                  # Объясните отличие от списков
(1, 2, 3)
>>> 
```

## (d) Сравнения

Еще одна проблема заключается в том, что сравнения все еще не работают. Например:

```python
>>> a = MutInt(3)
>>> b = MutInt(3)
>>> a == b
False
>>> a == 3
False
>>>
```

Это можно исправить, добавив метод `__eq__()` и другие методы, 
такие как `__lt__()`, `__le__()`, `__gt__()`, `__ge__()`, чтобы реализовать другие сравнения. Например:

```python
class MutInt:
    __slots__ = ['value']

    def __init__(self, value):
        self.value = value

    ...
    def __eq__(self, other):
        if isinstance(other, MutInt):
            return self.value == other.value
        elif isinstance(other, int):
            return self.value == other
        else:
            return NotImplemented
        
    def __lt__(self, other):
        if isinstance(other, MutInt):
            return self.value < other.value
        elif isinstance(other, int):
            return self.value < other
        else:
            return NotImplemented
```

Попробуйте:

```python
>>> a = MutInt(3)
>>> b = MutInt(3)
>>> a == b
True
>>> c = MutInt(4)
>>> a < c
True
>>> a <= c
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: '<=' not supported between instances of 'MutInt' and 'MutInt'
>>> 
```

Для предотвращения ошибки с оператором `<=`, который не работает, 
поскольку метод `__le__()` не был определен, можно использовать декоратор `@total_ordering`.

```python
from functools import total_ordering

@total_ordering
class MutInt:
    __slots__ = ['value']

    def __init__(self, value):
        self.value = value

    ...

    def __eq__(self, other):
        if isinstance(other, MutInt):
            return self.value == other.value
        elif isinstance(other, int):
            return self.value == other
        else:
            return NotImplemented
        
    def __lt__(self, other):
        if isinstance(other, MutInt):
            return self.value < other.value
        elif isinstance(other, int):
            return self.value < other
        else:
            return NotImplemented
```

`@total_ordering` заполняет недостающие методы сравнения, при условии, 
что вы предоставите метод для проверки равенства и одно из других отношений.

## (e) Преобразования

Ваш новый тип данных практически готов. 
Вы можете предоставить ему возможность работать с некоторыми распространенными преобразованиями. 
Например:

```python
>>> a = MutInt(3)
>>> int(a)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: int() argument must be a string, a bytes-like object or a number, not 'MutInt'
>>> float(a)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: float() argument must be a string, a bytes-like object or a number, not 'MutInt'
>>>
```

Вы можете добавить классу методы `__int__()` и `__float__()`, чтобы исправить это:

```python
from functools import total_ordering

@total_ordering
class MutInt:
    __slots__ = ['value']

    def __init__(self, value):
        self.value = value

    ...

    def __int__(self):
        return self.value

    def __float__(self):
        return float(self.value)
```

Теперь можно выполнять преобразования:

```python
>>> a = MutInt(3)
>>> int(a)
3
>>> float(a)
3.0
>>>
```

Однако, как правило, Python не конвертирует данные автоматически. Таким образом, хотя вы
дали классу метод `__int__()`, `MutInt` по-прежнему не будет работать во всех
ситуациях, когда можно ожидать целое число. Например, индексация:

```python
>>> names = ['Dave', 'Guido', 'Paula', 'Thomas', 'Lewis']
>>> a = MutInt(1)
>>> names[a]
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: list indices must be integers or slices, not MutInt
>>> 
```

Это можно исправить, предоставив `MutInt` метод `__index__()`.
Измените класс следующим образом:

```python
from functools import total_ordering

@total_ordering
class MutInt:
    __slots__ = ['value']

    def __init__(self, value):
        self.value = value

    ...

    def __int__(self):
        return self.value

    __index__ = __int__     # Добавляем индексацию
```


**Обсуждение**

Создание нового примитивного типа данных на самом деле является одной из самых сложных задач в Python. 
Существует много граничных случаев и важных низкоуровневых вопросов, которые нужно учесть, 
особенно в отношении взаимодействия вашего типа с другими типами данных в Python. Важно помнить, 
что вы можете настроить практически все аспекты взаимодействия объекта с остальной частью Python, 
если вы знаете основные протоколы. Если вы собираетесь это делать, рекомендуется посмотреть на существующий код 
для чего-то подобного тому, что вы пытаетесь создать.

\[ [Solution](soln2_4.md) | [Index](index.md) | [Exercise 2.3](ex2_3.md) | [Exercise 2.5](ex2_5.md) \]

----
`>>>` Advanced Python Mastery  
`...` A course by [dabeaz](https://www.dabeaz.com)  
`...` Copyright 2007-2023  

![](https://i.creativecommons.org/l/by-sa/4.0/88x31.png). This work is licensed under a [Creative Commons Attribution-ShareAlike 4.0 International License](http://creativecommons.org/licenses/by-sa/4.0/)
