\[ [Index](index.md) | [Exercise 2.5](ex2_5.md) | [Exercise 3.1](ex3_1.md) \]

# Упражнение 2.6

*Задачи:*

- Изучить преимущества объектов первого класса.
- Лучше понять модель памяти Python.

*Созданные файлы:* `reader.py`

В предыдущих упражнениях вы написали различные функции для чтения данных CSV из разных файлов. 
Несомненно, это проблема, которую можно было бы обобщить каким-то образом. 
В этом упражнении мы исследуем эту идею.

## (a) Объекты первого класса

В файле `Data/portfolio.csv`, вы читаете данные, организованные в виде столбцов, 
которые выглядят так:

```python
"AA",100,32.20
"IBM",50,91.10
...
```

В предыдущем коде эти данные обрабатывались путем 
жесткого кодирования всех преобразований типов. Например:

```python
rows = csv.reader(f)
for row in rows:
    name   = row[0]
    shares = int(row[1])
    price  = float(row[2])
```

Такое преобразование также может быть выполнено более 
умным способом с использованием некоторых операций со списками. 
Создайте список на языке Python, который содержит преобразования, 
которые вы хотите выполнить для каждого столбца:

```python
>>> coltypes = [str, int, float]
>>>
```

Вы можете создать этот список, потому что все в Python является "объектами первого класса". 
Так что, если вы хотите иметь список функций, это нормально.

Теперь прочитайте строку данных из указанного файла:

```python
>>> import csv
>>> f = open('Data/portfolio.csv')
>>> rows = csv.reader(f)
>>> headers = next(rows)
>>> row = next(rows)
>>> row
['AA', '100', '32.20']
>>>
```

Соедините типы столбцов с строкой и посмотрите на результат:

```python
>>> r = list(zip(coltypes, row))
>>> r
[(<class 'str'>, 'AA'), (<class 'int'>, '100'), (<class 'float'>,'32.20')]
>>>
```

Вы заметите, что это сопоставило преобразование типа со значением. 
Например, `int` сопоставлено со значением '100'. Теперь попробуйте следующее:

```python
>>> record = [func(val) for func, val in zip(coltypes, row)]
>>> record
['AA', 100, 32.2]
>>>
```

Убедитесь, что вы понимаете, что происходит в приведенном выше коде. 
В цикле переменная `func` является одной из функций преобразования 
типов (например, `str`, `int` и т. д.), а переменная `val` - одним из значений, 
таких как 'AA', '100'. Выражение `func(val)` преобразует значение (подобно приведению типов).

Вы можете пойти еще дальше и создать словари, используя заголовки столбцов. Например:

```python
>>> dict(zip(headers, record))
{'name': 'AA', 'shares': 100, 'price': 32.2}
>>>
```

Вы можете выполнить все эти шаги одновременно с помощью генератора словарей:

```python
>>> { name:func(val) for name, func, val in zip(headers, coltypes, row) }
{'name': 'AA', 'shares': 100, 'price': 32.2}
>>>
```

## (b) Создание вспомогательной функции

Создайте новый файл `reader.py`.   В этом файле определите 
вспомогательную функцию `read_csv_as_dicts()` которая читает файл данных CSV и 
возвращает список словарей, где пользователь указывает преобразования типов для каждого столбца.

Вот как это должно работать:

```python
>>> import reader
>>> portfolio = reader.read_csv_as_dicts('Data/portfolio.csv', [str,int,float])
>>> for s in portfolio:
         print(s)

{'name': 'AA', 'shares': 100, 'price': 32.2}
{'name': 'IBM', 'shares': 50, 'price': 91.1}
{'name': 'CAT', 'shares': 150, 'price': 83.44}
{'name': 'MSFT', 'shares': 200, 'price': 51.23}
{'name': 'GE', 'shares': 95, 'price': 40.37}
{'name': 'MSFT', 'shares': 50, 'price': 65.1}
{'name': 'IBM', 'shares': 100, 'price': 70.44}
>>>
```

Или, если вы можете прочитать другой файл:

```python
>>> rows = reader.read_csv_as_dicts('Data/ctabus.csv', [str,str,str,int])
>>> len(rows)
577563
>>> rows[0]
{'daytype': 'U', 'route': '3', 'rides': 7354, 'date': '01/01/2001'}
>>> 
```

## (c) Пересмотр памяти

В данных о маршрутах автобусов мы определили, что есть 181 уникальный маршрут автобуса.

```python
>>> routes = { row['route'] for row in rows }
>>> len(routes)
181
>>>
```

Вопрос: Сколько уникальных строковых объектов маршрутов содержится в данных о поездках?
Вместо создания набора маршрутов, создайте набор идентификаторов объектов:

```python
>>> routeids = { id(row['route']) for row in rows }
>>> len(routeids)
542305
>>>
```

Подумайте об этом некоторое время - есть только 181 различное имя маршрута, 
но результирующий список словарей содержит 542305 разных строковых объектов маршрутов. 
Возможно, это можно исправить с помощью небольшого кэширования или повторного 
использования объектов. Как оказалось, в Python есть функция, 
которая может использоваться для кэширования строк - `sys.intern()`. Например:

```python
>>> a = 'hello world'
>>> b = 'hello world'
>>> a is b
False
>>> import sys
>>> a = sys.intern(a)
>>> b = sys.intern(b)
>>> a is b
True
>>>
```

Перезапусти Python и попробуй следующее:

```python
>>> # ------------------ RESTART ---------```
>>> import tracemalloc
>>> tracemalloc.start()
>>> from sys import intern
>>> import reader
>>> rows = reader.read_csv_as_dicts('Data/ctabus.csv', [intern, str, str, int])
>>> routeids = { id(row['route']) for row in rows }
>>> len(routeids)
181
>>>
```

Обрати внимание на использование памяти. 

```python
>>> tracemalloc.get_traced_memory()
... посмотри на результат ...
>>> 
```

Память должна снизиться достаточно сильно.

Наблюдение: есть много повторения, связанных с датами. 
Что произойдет, если ты также кешируешь строковые представления дат?

```python
>>> # ------------------ RESTART ---------```
>>> import tracemalloc
>>> tracemalloc.start()
>>> from sys import intern
>>> import reader
>>> rows = reader.read_csv_as_dicts('Data/ctabus.csv', [intern, intern, str, int])
>>> tracemalloc.get_traced_memory()
... посмотри на результат ...
>>> 
```

## (d) Задание "Специальный проект"

В [Упражнении 2.5](ex2_5.md), мы создали класс `RideData` который хранил 
все данные о автобусах в столбцах, но на самом деле представлял данные 
пользователю как последовательность словарей. Это позволило сэкономить 
много памяти с помощью различных форм волшебства.

Можешь ли ты обобщить эту идею? В частности, можешь ли 
ты создать обобщенную функцию `read_csv_as_columns()`, которая будет работать следующим образом:

```python
>>> data = read_csv_as_columns('Data/ctabus.csv', types=[str, str, str, int])
>>> data
<__main__.DataCollection object at 0x102b45048>
>>> len(data)
577563
>>> data[0]
{'route': '3', 'date': '01/01/2001', 'daytype': 'U', 'rides': 7354}
>>> data[1]
{'route': '4', 'date': '01/01/2001', 'daytype': 'U', 'rides': 9288}
>>> data[2]
{'route': '6', 'date': '01/01/2001', 'daytype': 'U', 'rides': 6048}
>>> 
```

Эта функция должна быть универсальной — ты можешь передать ей любой файл 
и список типов столбцов, и она считает данные. Данные считываются 
в класс `DataCollection`, который внутренне хранит данные в виде столбцов. 
Однако при доступе к данным они представляют себя как последовательность словарей.

Попробуй использовать эту функцию с трюком интернирования строк в последнем разделе. 
Сколько памяти теперь требуется для хранения всех данных поездок? 
Ты все еще можешь использовать эту функцию с ранее написанным кодом для анализа поездок?

## (e) Глубокая мысль

В этом упражнении ты написал две функции:`read_csv_as_dicts()` и
`read_csv_as_columns()`.  Обе эти функции представляют данные пользователю в одинаковой форме. 
Например:

```python
>>> data1 = read_csv_as_dicts('Data/ctabus.csv', [str, str, str, int])
>>> len(data1)
577563
>>> data1[0]
{'route': '3', 'date': '01/01/2001', 'daytype': 'U', 'rides': 7354}
>>> data1[1]
{'route': '4', 'date': '01/01/2001', 'daytype': 'U', 'rides': 9288}
>>>

>>> data2 = read_csv_as_columns('Data/ctabus.csv', [str, str, str, int])
>>> len(data2)
577563
>>> data2[0]
{'route': '3', 'date': '01/01/2001', 'daytype': 'U', 'rides': 7354}
>>> data2[1]
{'route': '4', 'date': '01/01/2001', 'daytype': 'U', 'rides': 9288}
>>>
```

На самом деле ты можешь использовать любую из этих функций в коде 
анализа данных, который ты написал. Однако под капотом происходят 
совершенно разные вещи. Функция `read_csv_as_columns()` хранит данные в другом представлении. 
Она полагается на протокол последовательности Python, 
чтобы представить информацию в более удобном формате.

Это на самом деле является частью гораздо более общей концепции 
программирования — "Абстракции данных". Когда пишешь программы, 
способ представления данных часто более важен, чем способ, которым 
данные на самом деле объединены под капотом. Хотя мы представляем 
данные в виде последовательности словарей, существует большая гибкость в том, 
как это на самом деле происходит за кулисами. Это мощная идея и стоит 
подумать об этом, когда пишешь свои программы.

\[ [Solution](soln2_6.md) | [Index](index.md) | [Exercise 2.5](ex2_5.md) | [Exercise 3.1](ex3_1.md) \]

----
`>>>` Advanced Python Mastery  
`...` A course by [dabeaz](https://www.dabeaz.com)  
`...` Copyright 2007-2023  

![](https://i.creativecommons.org/l/by-sa/4.0/88x31.png). This work is licensed under a [Creative Commons Attribution-ShareAlike 4.0 International License](http://creativecommons.org/licenses/by-sa/4.0/)
